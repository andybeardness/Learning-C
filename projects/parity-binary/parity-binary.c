#include <stdio.h>
#include <time.h>

void timer(long maxiter, int loop_num);

void loop_basic(long maxiter);
void loop_binary(long maxiter);

/*
 * Сделал пять запусков программы:
 * Отметил знаком (+) победивший алгоритм
 * Время в секундах
 *
 *  * Вывод программы (запуск №1):
 * -------------------------------------------------------------
 * Time with algorithm "BASIC" == 28.359
 * Time with algorithm "BINARY" == 28.062 (+)
 * -------------------------------------------------------------
 *
 *  * Вывод программы (запуск №2):
 * -------------------------------------------------------------
 * Time with algorithm "BASIC" == 28.328 (+)
 * Time with algorithm "BINARY" == 28.343
 * -------------------------------------------------------------
 *
 *  * Вывод программы (запуск №3):
 * -------------------------------------------------------------
 * Time with algorithm "BASIC" == 28.250 (+)
 * Time with algorithm "BINARY" == 28.281
 * -------------------------------------------------------------
 *
 *  * Вывод программы (запуск №4):
 * -------------------------------------------------------------
 * Time with algorithm "BASIC" == 28.047
 * Time with algorithm "BINARY" == 27.952 (+)
 * -------------------------------------------------------------
 *
 *  * Вывод программы (запуск №5):
 * -------------------------------------------------------------
 * Time with algorithm "BASIC" == 28.000 (+)
 * Time with algorithm "BINARY" == 28.235
 * -------------------------------------------------------------
 *
 * =============================================================
 *
 * СЧЁТ:
 *      3 / 2
 *      в пользу алгоритма BASIC
 *
 * ВЫВОДЫ:
 *      Алгоритмы равноценны. Погрешность минимальная
 */

/**
 * Идея процесса в том, что:
 *      Алгоритм определения чётности числа может работать
 *      медленно из-за оператора "i % 2", который берёт
 *      остаток от деления на 2
 *
 * Чем заменить?
 *      Можно сравнивать биты у целых чисел
 *      Если последний бит == 0, то число нечётное
 *      В противном случае -- чётное
 *
 * Как реализовать?
 *      Сделать побитовое сравнение числа с единицей
 *      с помощью оператора "Побитовое И" (&)
 *
 * Пример:
 *      Сравниваая числа
 *      1 0 1 0 0 0 0 1  -- искомое число (может быть любым)
 *    х                 и
 *      0 0 0 0 0 0 0 1  -- наша единица
 *    =                 с помощью оператора & мы получим
 *      0 0 0 0 0 0 0 1  -- то есть единицу
 *
 *      В результате, если получилось единица, то число нечётное
 *      Если ноль -- чётное
 *
 * @return 0
 */
int main() {
    long maxiter = 5000000000L;

    timer(maxiter, 0);
    timer(maxiter, 1);

    return 0;
}

/**
 * Функция для подсчёта времени и выбора цикла
 *
 * @param maxiter -- кол-во итераций
 * @param loop_num -- номер цикла: 0 (BASIC) , 1 (BINARY)
 */
void timer(long maxiter, int loop_num) {
    clock_t begin, end;
    double time_spent;

    begin = clock();
    char *algo_name;

    if (loop_num == 0) {
        algo_name = "BASIC";
        loop_basic(maxiter);
    }
    else {
        algo_name = "BINARY";
        loop_binary(maxiter);
    }

    end = clock();
    time_spent = (double) (end - begin) / CLOCKS_PER_SEC;

    printf("Time with algorithm \"%s\" == %.3f\n", algo_name, time_spent);
}

/**
 * Цикл алгоритма BASIC
 *
 * @param maxiter  -- кол-во итераций
 */
void loop_basic(long maxiter) {
    int a = 0;

    for (long i = 0; i < maxiter; i++) {
        if (i % 2 == 0) {
            a++;
        }
        else {
            a--;
        }
    }
}

/**
 * Цикл алгоритма BINARY
 *
 * @param maxiter  -- кол-во итераций
 */
void loop_binary(long maxiter) {
    int a = 0;

    for (long i = 0; i < maxiter; i++) {
        if ((i&1) == 1) {
            a++;
        }
        else {
            a--;
        }
    }
}